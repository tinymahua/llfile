// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<SandbarAuth> generateAuth({required String password}) =>
    RustLib.instance.api.crateApiSandbarGenerateAuth(password: password);

Future<Uint8List> generateAesKey() =>
    RustLib.instance.api.crateApiSandbarGenerateAesKey();

Future<Uint8List> aesEncrypt(
        {required List<int> palAesKeyBytes, required List<int> plainBytes}) =>
    RustLib.instance.api.crateApiSandbarAesEncrypt(
        palAesKeyBytes: palAesKeyBytes, plainBytes: plainBytes);

Future<Uint8List> aesDecrypt(
        {required List<int> palAesKeyBytes,
        required List<int> encryptedBytes,
        BigInt? nonceLen}) =>
    RustLib.instance.api.crateApiSandbarAesDecrypt(
        palAesKeyBytes: palAesKeyBytes,
        encryptedBytes: encryptedBytes,
        nonceLen: nonceLen);

Future<CbKeyPair> generateCbKeyPair() =>
    RustLib.instance.api.crateApiSandbarGenerateCbKeyPair();

Future<Uint8List> cbEncrypt(
        {required List<int> peerPalCryptoPublicKeyBytes,
        required List<int> myPalCryptoSecretKeyBytes,
        required List<int> plainBytes}) =>
    RustLib.instance.api.crateApiSandbarCbEncrypt(
        peerPalCryptoPublicKeyBytes: peerPalCryptoPublicKeyBytes,
        myPalCryptoSecretKeyBytes: myPalCryptoSecretKeyBytes,
        plainBytes: plainBytes);

Future<Uint8List> cbDecrypt(
        {required List<int> peerPalCryptoPublicKeyBytes,
        required List<int> myPalCryptoSecretKeyBytes,
        required List<int> encryptedBytes,
        BigInt? nonceLen}) =>
    RustLib.instance.api.crateApiSandbarCbDecrypt(
        peerPalCryptoPublicKeyBytes: peerPalCryptoPublicKeyBytes,
        myPalCryptoSecretKeyBytes: myPalCryptoSecretKeyBytes,
        encryptedBytes: encryptedBytes,
        nonceLen: nonceLen);

Future<Uint8List> argon2PwdHash({required List<int> password}) =>
    RustLib.instance.api.crateApiSandbarArgon2PwdHash(password: password);

class CbKeyPair {
  final String publicKeyBytesB64;
  final String privateKeyBytesB64;

  const CbKeyPair({
    required this.publicKeyBytesB64,
    required this.privateKeyBytesB64,
  });

  @override
  int get hashCode => publicKeyBytesB64.hashCode ^ privateKeyBytesB64.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CbKeyPair &&
          runtimeType == other.runtimeType &&
          publicKeyBytesB64 == other.publicKeyBytesB64 &&
          privateKeyBytesB64 == other.privateKeyBytesB64;
}

class SandbarAuth {
  final String masterKeyBytesB64;
  final String masterKeyEncryptedBytesB64;
  final String publicKeyBytesB64;
  final String privateKeyBytesB64;
  final String privateKeyEncryptedBytesB64;

  const SandbarAuth({
    required this.masterKeyBytesB64,
    required this.masterKeyEncryptedBytesB64,
    required this.publicKeyBytesB64,
    required this.privateKeyBytesB64,
    required this.privateKeyEncryptedBytesB64,
  });

  @override
  int get hashCode =>
      masterKeyBytesB64.hashCode ^
      masterKeyEncryptedBytesB64.hashCode ^
      publicKeyBytesB64.hashCode ^
      privateKeyBytesB64.hashCode ^
      privateKeyEncryptedBytesB64.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SandbarAuth &&
          runtimeType == other.runtimeType &&
          masterKeyBytesB64 == other.masterKeyBytesB64 &&
          masterKeyEncryptedBytesB64 == other.masterKeyEncryptedBytesB64 &&
          publicKeyBytesB64 == other.publicKeyBytesB64 &&
          privateKeyBytesB64 == other.privateKeyBytesB64 &&
          privateKeyEncryptedBytesB64 == other.privateKeyEncryptedBytesB64;
}
